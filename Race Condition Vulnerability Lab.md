# Environment Setup

## Turning Off Countermeasures

![image](https://github.com/udayk01/Secure_Coding/assets/52235763/e94ff170-6060-46e3-a8f2-e3f40d7e4e82)

We first compile the code vulp.c, and turn its binary into a Set-UID program that is owned by the root. The following commands achieve this goal

![image](https://github.com/udayk01/Secure_Coding/assets/52235763/274e6188-5657-4686-8936-09742658f517)

# Task 1: Choosing Our Target

![image](https://github.com/udayk01/Secure_Coding/assets/52235763/042b8b73-19d9-4612-8d82-3f4b0f143477)
![image](https://github.com/udayk01/Secure_Coding/assets/52235763/e5a9e6b4-d28c-4d45-a200-cca812d1de42)

Manually added the new user in the **/etc/passwd** file, and verified that we are able to login to the created user.

![image](https://github.com/udayk01/Secure_Coding/assets/52235763/d9f76382-d2d3-4f95-b09e-71ee7b3686bc)

After the task the added line in **/etc/passwd** file is deleted.

# Task 2: Launching the Race Condition Attack

![image](https://github.com/udayk01/Secure_Coding/assets/52235763/f901e7c6-e539-41d0-b466-9cde8a7a9504)

## Task 2.A: Simulating a Slow Machine

Added sleep(10); to the vulp.c file.

![image](https://github.com/udayk01/Secure_Coding/assets/52235763/94cd8520-fabe-485c-9c22-9672605e9ed7)

![image](https://github.com/udayk01/Secure_Coding/assets/52235763/1800d30e-4bbf-4b77-9f17-4b671d0773b3)

Within 10s after running the vulp ie. **./vulp** run the command given below.

![image](https://github.com/udayk01/Secure_Coding/assets/52235763/92b08d99-e8f7-49c2-9abd-96cbb0ee5e3f)

After which check whether test user is created in **/etc/passwd**

![image](https://github.com/udayk01/Secure_Coding/assets/52235763/201a06ec-0f2c-4269-b3cf-6aedcfe0b50c)
![image](https://github.com/udayk01/Secure_Coding/assets/52235763/c783a41f-f075-4a70-b659-4b1d43639bbe)

After which check wether you can switch to the newly created user.

![image](https://github.com/udayk01/Secure_Coding/assets/52235763/a3482a8f-56ea-470b-9040-b045483e2de2)

##  Task 2.B: The Real Attack

Removed **/etc/passwd** entry, and **sleep(10)** from vulp.c

Writing the attack program.

Created a C program and compiled it to attack.

![image](https://github.com/udayk01/Secure_Coding/assets/52235763/ed8ff6db-9c84-4bfd-9435-445f191ca6d0)

The **target_process.sh** is updated as follows.

![image](https://github.com/udayk01/Secure_Coding/assets/52235763/339b9c1b-ec88-4760-9590-9f7ac8046afc)

After which **target_process.sh** and **attack** are run simultaneously in 2 windows. Sometimes you might have to run the attack in multiple windows so as to get it.  

![image](https://github.com/udayk01/Secure_Coding/assets/52235763/1f0d9352-ffd5-42c4-b7dc-cf4dd333c19e)
![image](https://github.com/udayk01/Secure_Coding/assets/52235763/b23cdc07-e1e0-476a-b94d-e56ad5216966)

Then check the **/etc/passwd** file.

![image](https://github.com/udayk01/Secure_Coding/assets/52235763/bf664aea-67b0-4c79-950b-5ddebe1f5076)
![image](https://github.com/udayk01/Secure_Coding/assets/52235763/f267979a-291d-467d-8502-71d24eaffb21)

As we can see a user is created in the **/etc/passwd** file now switch user to **test** and verify.

![image](https://github.com/udayk01/Secure_Coding/assets/52235763/96439597-683f-4b83-85e7-7dd115c2ba6d)

## Task 2.C: An Improved Attack Method

![image](https://github.com/udayk01/Secure_Coding/assets/52235763/c19c4955-56a6-444d-b54c-5760d30b8c53)

The permissions of **/tmp/XYZ** is seed and not root so this can't be performed.

#  Task 3: Countermeasures

##  Task 3.A: Applying the Principle of Least Privilege

Edit the vulp.c as shown below and create the executable and make it into setuid.
 
![image](https://github.com/udayk01/Secure_Coding/assets/52235763/9f117eba-b9d2-4360-8133-74b7f2efe423)

![image](https://github.com/udayk01/Secure_Coding/assets/52235763/9b6467a2-ff6a-4f22-b48c-92cd5db76d9d)

Launching the attack.

Running **Target_process.sh** and **attack** simultaneously, we can see that we can't get permission even after many try's.

![image](https://github.com/udayk01/Secure_Coding/assets/52235763/4501800f-050a-441b-9d06-86504e714945)

We are getting **No Permission** because **access**,**fopen** and **fwrite** system calls do not have permission to write to the root owned **/etc/passwd** file and hence we can conclude the attack failed.

##  Task 3.B: Using Ubuntuâ€™s Built-in Scheme

![image](https://github.com/udayk01/Secure_Coding/assets/52235763/c48e76e3-d628-40fc-bf9d-2ba821c4a780)

Launching the attack again.

![image](https://github.com/udayk01/Secure_Coding/assets/52235763/51db2051-aa14-4545-8dcd-e7f48433874c)

1-) How does the protection scheme work ?

Symbolic Link protection only allows **fopen** system call, when the owner of the symbolic link match either the follower or the directory owner.

2-) What are the limitations of this scheme ?

They block a nonprivileged user from hardlinking / softlinking to files that they do not own.

 




 


 







  


